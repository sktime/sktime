"""Interval-based changepoint detection for time series."""

__all__ = ["Interval base changepoint Detector"]
__author__ = ["Artinong"]
import numpy as np
import pandas as pd
from sktime.classification.base import BaseClassifier
from collections import deque
from sktime.forecasting.fbprophet import Prophet

class IntervalBasedChangePointDetector(BaseClassifier):
    
    """Change point detector that uses forecasting intervals to detect sustained changes.
    Detects change points by checking if a minimum number of consecutive observations 
    fall outside prediction intervals generated by a forecaster.
    
    Parameters
    ----------
    forecaster : BaseForecaster
        The forecaster to use for generating prediction intervals
    coverage : float, default=0.95
        The coverage of the prediction interval (between 0 and 1)
    min_violations : int, default=3
        Minimum number of consecutive points outside the interval to signal a change point
    window_size : int, default=10
        Number of past observations to consider when detecting change points
    z_threshold : float, default=1.0
        Threshold for considering a violation based on z-scores
        Examples
    --------
    >>> from sktime.forecasting.naive import NaiveForecaster
    >>> detector = IntervalBasedChangePointDetector(
    ...     forecaster=NaiveForecaster(),
    ...     coverage=0.95,
    ...     min_violations=3,
    ...     window_size=10
    ... )
    >>> detector.fit(X_train)
    >>> change_points = detector.predict(X_test)
    >>> scores = detector.predict_proba(X_test)
    """
    def __init__(self, forecaster, coverage=0.95, min_violations=3, window_size=10, z_threshold=1.0):
        super().__init__()

        if not isinstance(forecaster, BaseClassifier):
            raise ValueError("forecaster must be a BaseForecaster instance")

        if not forecaster.get_tag("capability:pred_int"):
            raise ValueError("forecaster must support prediction intervals")

        if not 0 < coverage < 1:
            raise ValueError("coverage must be between 0 and 1")
            
        if min_violations < 1:
            raise ValueError("min_violations must be at least 1")
            
        if window_size < min_violations:
            raise ValueError("window_size must be greater than or equal to min_violations")
            
        self.forecaster = forecaster
        self.coverage = coverage
        self.min_violations = min_violations
        self.window_size = window_size
        self.z_threshold = z_threshold

    def _fit(self, X, y=None):
        """Fit the change point detector."""
        self.forecaster_ = self.forecaster.clone()
        self.forecaster_.fit(X)
        return self

    def _predict(self, X):
        """Predict change point labels."""
        fh = X.index
        pred_int = self.forecaster_.predict_interval(fh=fh, coverage=self.coverage)
        
        # Extract lower and upper bounds
        lower = pred_int.xs("lower", level=-1, axis=1)
        upper = pred_int.xs("upper", level=-1, axis=1)
        
        # Mark points outside the interval
        violations = (X < lower) | (X > upper)
        
        # Initialize change points array
        change_points = pd.Series(0, index=X.index)
        
        # Use a deque for efficient sliding window
        violation_window = deque(maxlen=self.window_size)
        
        for i, violation in enumerate(violations):
            violation_window.append(violation)
            
            if len(violation_window) == self.window_size:
                # Count consecutive violations
                consecutive_violations = self._count_max_consecutive_true(violation_window)
                if consecutive_violations >= self.min_violations:
                    change_points.iloc[i] = 1
        
        return change_points

    def _predict_proba(self, X):
        """Predict change point probabilities."""
        fh = X.index
        pred_int = self.forecaster_.predict_interval(fh=fh, coverage=self.coverage)

        # Extract bounds
        lower = pred_int.xs("lower", level=-1, axis=1)
        upper = pred_int.xs("upper", level=-1, axis=1)

        # Calculate z-scores (distance from center of interval)
        center = (upper + lower) / 2
        width = upper - lower
        z_scores = np.abs(X - center) / (width / 2)
        
        # Initialize probabilities
        probs = pd.Series(0.0, index=X.index)
        
        # Use a deque for efficient sliding window
        z_score_window = deque(maxlen=self.window_size)
        
        for i, z_score in enumerate(z_scores):
            z_score_window.append(z_score)
            
            if len(z_score_window) == self.window_size:
                # Calculate probability based on consecutive z-score violations
                consecutive_violations = self._count_consecutive_violations(z_score_window)
                prob = consecutive_violations / self.min_violations
                prob = min(1.0, prob)
                probs.iloc[i] = prob
        
        return pd.DataFrame(probs, index=X.index)

    def _count_max_consecutive_true(self, series):
        """Helper method to count max consecutive True values in a series."""
        counts = [sum(1 for _ in group) for value, group in groupby(series) if value]
        return max(counts) if counts else 0

    def _count_consecutive_violations(self, z_scores):
        """Helper method to count consecutive violations based on z-scores."""
        violations = z_scores > self.z_threshold
        return self._count_max_consecutive_true(violations)

    @classmethod
    def get_test_params(cls, parameter_set="default"):
        """Return testing parameter settings for the estimator."""
        from sktime.forecasting.naive import NaiveForecaster

        params = {
            "forecaster": NaiveForecaster(strategy="mean"),
            "coverage": 0.9,
            "min_violations": 3,
        }
