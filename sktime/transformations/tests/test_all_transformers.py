# copyright: sktime developers, BSD-3-Clause License (see LICENSE file)
"""Unit tests common to all transformers."""

__author__ = ["mloning", "fkiraly"]
__all__ = []

import pandas as pd
import pytest

from sktime.datatypes import check_is_scitype, convert_to
from sktime.registry import all_estimators
from sktime.tests.test_all_estimators import BaseFixtureGenerator, QuickTester
from sktime.tests.test_switch import run_test_for_class
from sktime.transformations.hierarchical.aggregate import Aggregator
from sktime.transformations.panel.dictionary_based import SFAFast
from sktime.utils._testing.estimator_checks import _assert_array_almost_equal
from sktime.utils._testing.hierarchical import _bottom_hier_datagen
from sktime.utils._testing.panel import _make_panel


class TransformerFixtureGenerator(BaseFixtureGenerator):
    """Fixture generator for transformer tests.

    Fixtures parameterized
    ----------------------
    estimator_class: estimator inheriting from BaseObject
        ranges over all estimator classes not excluded by EXCLUDED_TESTS
    estimator_instance: instance of estimator inheriting from BaseObject
        ranges over all estimator classes not excluded by EXCLUDED_TESTS
        instances are generated by create_test_instance class method
    scenario: instance of TestScenario
        ranges over all scenarios returned by retrieve_scenarios
    """

    # note: this should be separate from TestAllTransformers
    #   additional fixtures, parameters, etc should be added here
    #   TestAllTransformers should contain the tests only

    estimator_type_filter = "transformer"


class TestAllTransformers(TransformerFixtureGenerator, QuickTester):
    """Module level tests for all sktime transformers."""

    def test_capability_inverse_tag_is_correct(self, estimator_instance):
        """Test that the capability:inverse_transform tag is set correctly."""
        capability_tag = estimator_instance.get_tag("capability:inverse_transform")
        skip_tag = estimator_instance.get_tag("skip-inverse-transform")
        if capability_tag and not skip_tag:
            assert estimator_instance._has_implementation_of("_inverse_transform")

    def test_remember_data_tag_is_correct(self, estimator_instance):
        """Test that the remember_data tag is set correctly."""
        fit_empty_tag = estimator_instance.get_tag("fit_is_empty", True)
        remember_data_tag = estimator_instance.get_tag("remember_data", False)
        msg = (
            'if the "remember_data" tag is set to True, then the "fit_is_empty" tag '
            "must be set to False, even if _fit is not implemented or empty. "
            "This is due to boilerplate that write to self.X in fit. "
            f"Please check these two tags in {type(estimator_instance)}."
        )
        if fit_empty_tag and remember_data_tag:
            raise AssertionError(msg)

    def _expected_trafo_output_scitype(self, X_scitype, trafo_input, trafo_output):
        """Return expected output scitype, given X scitype and input/output.

        Parameters
        ----------
        X_scitype : str, scitype of the input to transform
        trafo_input : str, scitype of "instance"
        trafo_output : str, scitype that instance is being transformed to

        Returns
        -------
        expected scitype of the output of transform
        """
        # if series-to-series: input scitype equals output scitype
        if trafo_input == "Series" and trafo_output == "Series":
            return X_scitype
        if trafo_output == "Primitives":
            return "Table"
        if trafo_input == "Series" and trafo_output == "Panel":
            if X_scitype == "Series":
                return "Panel"
            if X_scitype in ["Panel", "Hierarchical"]:
                return "Hierarchical"
        if trafo_input == "Panel" and trafo_output == "Series":
            if X_scitype == "Hierarchical":
                # Could be Hierarchical or Panel, depending on the
                # depth of the hierarchy
                return ["Panel", "Hierarchical"]
            return "Series"

    def test_fit_transform_output(self, estimator_instance, scenario):
        """Test that transform output is of expected scitype."""
        X = scenario.args["transform"]["X"]
        Xt = scenario.run(estimator_instance, method_sequence=["fit", "transform"])

        X_scitype = scenario.get_tag("X_scitype")
        trafo_input = estimator_instance.get_tag("scitype:transform-input")
        trafo_output = estimator_instance.get_tag("scitype:transform-output")

        # get metadata for X and ensure that X_scitype tag was correct
        valid_X_scitype, _, X_metadata = check_is_scitype(
            X, scitype=X_scitype, return_metadata=True
        )
        msg = (
            f"error with scenario {type(scenario).__name__}, X_scitype tag "
            f'was "{X_scitype}", but check_is_scitype does not confirm this'
        )
        assert valid_X_scitype, msg

        Xt_expected_scitype = self._expected_trafo_output_scitype(
            X_scitype, trafo_input, trafo_output
        )

        valid_scitype, _, Xt_metadata = check_is_scitype(
            Xt, scitype=Xt_expected_scitype, return_metadata=True
        )

        msg = (
            f"{type(estimator_instance).__name__}.transform should return an object of "
            f"scitype {Xt_expected_scitype} when given an input of scitype {X_scitype},"
            f" but found the following return: {Xt}"
        )
        assert valid_scitype, msg

        # we now know that Xt has its expected scitype
        # assign this variable for better readability
        Xt_scitype = Xt_expected_scitype

        # skip the "number of instances" test below for Aggregator, Reconciler
        #   reason: this adds "pseudo-instances" for the __total and increases the count
        #   todo: we probably want to mirror this into a "hierarchical" tag later on
        if type(estimator_instance).__name__ in ["Aggregator", "Reconciler"]:
            return None

        # if DataFrame is returned, columns must be unique
        if hasattr(Xt, "columns"):
            msg = (
                f"{type(estimator_instance).__name__}.transform return should have "
                f"unique column indices, but found {Xt.columns}"
            )
            assert Xt.columns.is_unique, msg

        # if we vectorize, number of instances before/after transform should be same

        # series-to-series transformers
        if trafo_input == "Series" and trafo_output == "Series":
            if X_scitype == "Series" and Xt_scitype == "Series":
                if estimator_instance.get_tag("transform-returns-same-time-index"):
                    assert X.shape[0] == Xt.shape[0]

        # panel-to-panel transformers
        if trafo_input == "Panel" and trafo_output == "Panel":
            if X_scitype == "Hierarchical" and Xt_scitype == "Hierarchical":
                assert X_metadata["n_panels"] == Xt_metadata["n_panels"]

        # series-to-primitives transformers
        if trafo_input == "Series" and trafo_output == "Primitives":
            if X_scitype == "Series":
                assert Xt_metadata["n_instances"] == 1
            if X_scitype == "Panel":
                assert X_metadata["n_instances"] == Xt_metadata["n_instances"]

        # todo: also test the expected mtype

    def test_transform_inverse_transform_equivalent(self, estimator_instance, scenario):
        """Test that inverse_transform is indeed inverse to transform."""
        # skip this test if the estimator does not have inverse_transform
        if not estimator_instance.get_class_tag("capability:inverse_transform", False):
            return None

        # skip this test if the estimator skips inverse_transform
        if estimator_instance.get_tag("skip-inverse-transform", False):
            return None

        # skip this test if inverse_transform is not assumed an exact inverse
        if not estimator_instance.get_tag("capability:inverse_transform:exact", True):
            return None

        X = scenario.args["transform"]["X"]
        Xt = scenario.run(estimator_instance, method_sequence=["fit", "transform"])
        Xit = estimator_instance.inverse_transform(Xt)

        # if inversion produces more indices, we subset to the original X indices
        if not estimator_instance.get_tag("transform-returns-same-time-index"):
            if isinstance(X, pd.DataFrame):
                X = X.loc[Xit.index]

        # check that the inverse transform is indeed the inverse
        # we check this only on entries within range of invertibility, if specified
        inv_range = estimator_instance.get_tag("capability:inverse_transform:range")
        if inv_range is None:
            _assert_array_almost_equal(X, Xit)
        else:
            # convert to pd.DataFrame so that we can use masks
            df_types = ["pd.DataFrame", "pd-multiindex", "pd_multiindex_hier"]
            X = convert_to(X, df_types)
            Xit = convert_to(Xit, df_types)

            # mask entries of X outside range of invertibility
            # then compare for identity
            inside_mask = (X >= inv_range[0]) * (X <= inv_range[1])
            _assert_array_almost_equal(X[inside_mask], Xit[inside_mask])

    def test_categorical_X_raises_error(self, estimator_instance):
        """Test that error is raised when categorical is not supported in X."""
        X = pd.DataFrame({"var_0": ["a", "b", "c", "a", "b", "c"]})
        y = pd.DataFrame({"var_0": [1, 2, 3, 4, 5, 6]})

        # SFAFast transformer requires nested dataframe for X.
        # so testing all transformers apart from it.
        if isinstance(estimator_instance, SFAFast):
            pass
        elif not estimator_instance.get_tag("capability:categorical_in_X"):
            with pytest.raises(TypeError, match=r"categorical"):
                estimator_instance.fit_transform(X, y)

    def test_categorical_y_raises_error(self, estimator_instance):
        """Test that error is raised when categorical data is passed in y."""
        X = pd.DataFrame({"var_0": [1, 2, 3, 4, 5, 6]})
        y = pd.DataFrame({"var_0": ["a", "b", "c", "a", "b", "c"]})

        # SFAFast transformer requires nested dataframe for X.
        # so testing all transformers apart from it.
        if isinstance(estimator_instance, SFAFast):
            pass
        elif estimator_instance.get_tag("requires_y"):
            with pytest.raises(TypeError, match=r"categorical"):
                estimator_instance.fit_transform(X, y)

    def test_categorical_X_passes(self, estimator_instance):
        """Test that error is not raised when categorical is supported in X.

        Not testing composites such as pipelines as they may raise error if estimators
        used within do not support categorical.
        """
        X = pd.DataFrame({"var_0": ["a", "b", "c", "a", "b", "c"]})
        y = pd.DataFrame({"var_0": [1, 2, 3, 4, 5, 6]})

        # SFAFast transformer requires nested dataframe for X.
        # so testing all transformers apart from it.
        if isinstance(estimator_instance, SFAFast):
            pass
        elif (
            estimator_instance.get_tag("capability:categorical_in_X")
            and not estimator_instance.is_composite()
        ):
            estimator_instance.fit_transform(X, y)


# todo: add testing of inverse_transform
# todo: refactor the below, equivalent index check

# def check_transform_returns_same_time_index(Estimator):
#     estimator = Estimator.create_test_instance()
#     if estimator.get_tag("transform-returns-same-time-index"):
#         assert issubclass(Estimator, (_SeriesToSeriesTransformer, BaseTransformer))
#         estimator = Estimator.create_test_instance()
#         fit_args = _make_args(estimator, "fit")
#         estimator.fit(*fit_args)
#         for method in ["transform", "inverse_transform"]:
#             if _has_capability(estimator, method):
#                 X = _make_args(estimator, method)[0]
#                 Xt = estimator.transform(X)
#                 np.testing.assert_array_equal(X.index, Xt.index)


class ReconciliationTransformerFixtureGenerator(BaseFixtureGenerator):
    """Fixture generator for transformer tests.

    Uses the tag "capability:hierarchical_reconciliation" to
    filter for transformers

    Fixtures parameterized
    ----------------------
    estimator_class: estimator inheriting from BaseTransformer and
        with the tag "capability:hierarchical_reconciliation" set to True
    estimator_instance: instance of estimator inheriting from BaseTransformer
        and with the tag "capability:hierarchical_reconciliation" set to True
    scenario: instance of TestScenario
    ranges over all scenarios returned by retrieve_scenarios
    """

    # note: this should be separate from TestAllTransformers
    #   additional fixtures, parameters, etc should be added here
    #   TestAllTransformers should contain the tests only

    estimator_type_filter = "transformer"

    def _all_estimators(self):
        """Retrieve list of all estimator classes of type self.estimator_type_filter."""
        filter_tags = {
            "capability:hierarchical_reconciliation": True,
        }

        est_list = all_estimators(
            estimator_types=getattr(self, "estimator_type_filter", None),
            return_names=False,
            filter_tags=filter_tags,
        )

        est_list = [est for est in est_list if run_test_for_class(est)]

        return est_list


class TestAllReconciliationTransformers(
    ReconciliationTransformerFixtureGenerator, QuickTester
):
    """Module level tests for all sktime transformers."""

    @pytest.mark.parametrize("no_levels", [1, 2, 3, 4])
    @pytest.mark.parametrize("flatten_single_levels", [True, False])
    @pytest.mark.parametrize("unnamed_levels", [True, False])
    @pytest.mark.parametrize("aggregate", [True, False])
    def test_hierarchical_reconcilers(
        self,
        estimator_instance,
        no_levels,
        flatten_single_levels,
        unnamed_levels,
        aggregate,
    ):
        """Test that hierarchical transformers can handle hierarchical data.

        * Test different number of hierarchical levels. The methods should work
            for any number of levels.
        * Test with and without flattening single levels. The methods should
        return the same original number of series.

        """
        # skip this test if the estimator is not hierarchical
        import numpy as np
        from pandas.testing import assert_frame_equal

        X = _bottom_hier_datagen(
            no_bottom_nodes=5,
            no_levels=no_levels,
            random_seed=123,
        )
        # add aggregate levels

        if aggregate:
            agg = Aggregator(flatten_single_levels=flatten_single_levels)
            X = agg.fit_transform(X)

        if unnamed_levels:
            X.index.names = [None] * X.index.nlevels

        X = X + np.random.normal(0, 10, (X.shape[0], 1))

        # reconcile forecasts
        reconciler = estimator_instance
        Xt = reconciler.fit_transform(X)
        prds = Xt + np.random.normal(0, 10, (Xt.shape[0], 1))
        prds_recon = reconciler._inverse_transform_reconciler(prds)

        # Assert hierarchy detected
        assert not reconciler._no_hierarchy
        # Assert not empty
        assert not prds_recon.empty
        # Assert no Nans
        assert not prds_recon.isnull().values.any()

        # check if we now remove aggregate levels and use Aggregator it is equal
        prds_recon_bottomlevel = Aggregator(False).fit_transform(prds_recon)
        prds_recon_bottomlevel = prds_recon_bottomlevel.loc[prds_recon.index]
        assert_frame_equal(prds_recon, prds_recon_bottomlevel)

    def test_implement_inverse_transform(self, estimator_instance):
        """Test that the reconciler has implemented the inverse_transform method."""
        methods_to_implement = [
            "_inverse_transform_reconciler",
        ]

        for method in methods_to_implement:
            assert method in estimator_instance.__class__.__dict__

    @pytest.mark.parametrize("n_instances", [1, 10])
    def test_behaves_as_identity_if_input_not_hierarchical(
        self, estimator_instance, n_instances
    ):
        """Test that the reconciler behaves as identity when required."""
        X = _make_panel(n_instances=20)

        # reconcile forecasts
        reconciler = estimator_instance
        Xt = reconciler.fit_transform(X)

        assert reconciler._no_hierarchy
        assert Xt.equals(X)

        Xinv = reconciler.inverse_transform(Xt)
        assert Xinv.equals(X)
